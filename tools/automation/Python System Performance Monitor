{"cells":[{"cell_type":"code","source":"# Import necessary libraries\nimport psutil  # For system and process utilities\nimport time    # For pausing the script\nimport datetime # For timestamping\nimport csv     # For writing data to a CSV file\nimport os      # For checking if the log file exists\n\n# --- Configuration ---\nLOG_INTERVAL = 5  # Seconds between each log entry\nLOG_FILE = \"system_performance_log.csv\" # Name of the log file\nFIELDNAMES = ['timestamp', 'cpu_percent', 'memory_percent', 'memory_used_mb', 'memory_total_mb'] # CSV header\n\ndef get_system_performance():\n    \"\"\"\n    Retrieves current CPU and memory usage.\n\n    Returns:\n        dict: A dictionary containing CPU percentage, memory percentage,\n              memory used (MB), and total memory (MB).\n              Returns None if an error occurs.\n    \"\"\"\n    try:\n        # Get CPU usage percentage\n        cpu_percent = psutil.cpu_percent(interval=1) # Interval of 1 second for a more accurate reading\n\n        # Get memory usage\n        memory_info = psutil.virtual_memory()\n        memory_percent = memory_info.percent\n        memory_used_mb = memory_info.used / (1024 * 1024)  # Convert bytes to MB\n        memory_total_mb = memory_info.total / (1024 * 1024) # Convert bytes to MB\n\n        return {\n            \"cpu_percent\": cpu_percent,\n            \"memory_percent\": memory_percent,\n            \"memory_used_mb\": round(memory_used_mb, 2),\n            \"memory_total_mb\": round(memory_total_mb, 2)\n        }\n    except Exception as e:\n        print(f\"Error getting system performance: {e}\")\n        return None\n\ndef log_performance_data(writer, data):\n    \"\"\"\n    Writes a single row of performance data to the CSV file.\n\n    Args:\n        writer (csv.DictWriter): The CSV writer object.\n        data (dict): The performance data to log.\n    \"\"\"\n    try:\n        writer.writerow(data)\n    except Exception as e:\n        print(f\"Error writing to log file: {e}\")\n\ndef main():\n    \"\"\"\n    Main function to monitor system performance and log data.\n    \"\"\"\n    print(f\"Starting system performance monitoring. Logging to '{LOG_FILE}' every {LOG_INTERVAL} seconds.\")\n    print(\"Press Ctrl+C to stop.\")\n\n    # Check if the log file exists to determine if we need to write headers\n    file_exists = os.path.isfile(LOG_FILE)\n\n    try:\n        with open(LOG_FILE, mode='a', newline='', encoding='utf-8') as csvfile:\n            # Create a CSV DictWriter object\n            # DictWriter is used to write dictionaries to a CSV file\n            writer = csv.DictWriter(csvfile, fieldnames=FIELDNAMES)\n\n            # Write the header row if the file is new\n            if not file_exists or os.path.getsize(LOG_FILE) == 0:\n                writer.writeheader()\n                print(\"Log file created and header written.\")\n\n            while True:\n                # Get current timestamp\n                now = datetime.datetime.now()\n                timestamp_str = now.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n                # Get performance data\n                performance_data = get_system_performance()\n\n                if performance_data:\n                    # Prepare data row for CSV\n                    log_entry = {\n                        'timestamp': timestamp_str,\n                        'cpu_percent': performance_data['cpu_percent'],\n                        'memory_percent': performance_data['memory_percent'],\n                        'memory_used_mb': performance_data['memory_used_mb'],\n                        'memory_total_mb': performance_data['memory_total_mb']\n                    }\n\n                    # Log the data\n                    log_performance_data(writer, log_entry)\n                    # Flush the writer buffer to ensure data is written immediately\n                    csvfile.flush()\n\n                    # Print to console (optional)\n                    print(f\"{timestamp_str} - CPU: {performance_data['cpu_percent']}% | Memory: {performance_data['memory_percent']}% ({performance_data['memory_used_mb']}MB / {performance_data['memory_total_mb']}MB)\")\n\n                # Wait for the defined interval\n                time.sleep(LOG_INTERVAL)\n\n    except KeyboardInterrupt:\n        print(\"\\nMonitoring stopped by user.\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n    finally:\n        print(f\"Data logged to '{LOG_FILE}'.\")\n\nif __name__ == \"__main__\":\n    # This ensures the main function is called only when the script is executed directly\n    main()","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}