#!/usr/bin/env python3
"""project_intake_audit.py

Author: cbwinslow
Date: 2025-11-16

Summary:
    Analyze a project directory to understand its current state:
    - File types and counts
    - Approximate lines of code by extension
    - Presence of key docs (SRS, FEATURES, etc.)
    - Rough qualitative complexity and resource hints

    This acts as part of the "opening balance sheet" for a project/agent.

Inputs:
    - --root / -r : Root directory of the project (default: current directory)
    - --output / -o : Markdown report path (default: ./project_intake_report.md)

Outputs:
    - Markdown file summarizing:
        - Project tree stats
        - Language / extension breakdown
        - Presence or absence of key documentation
        - Very rough subjective hints that can guide time/memory estimates

Usage:
    python project_intake_audit.py
    python project_intake_audit.py --root . --output snapshots/project_intake_report.md

Notes:
    - This script is intentionally conservative and read-only.
    - It is safe to run on large trees, but you may want to exclude massive dirs.

Modification Log:
    - 2025-11-16 : Initial version generated by AI assistant.
"""


import argparse
import math
import os
import sys
import time
from pathlib import Path
from typing import Dict, List, Tuple


KEY_DOCS = [
    "SRS.md",
    "FEATURES.md",
    "PROJECT_SUMMARY.md",
    "TASKS.md",
    "JOURNAL.md",
]


def scan_tree(root: Path) -> Tuple[Dict[str, int], Dict[str, int], int]:
    """Walk the tree and gather:
    - file_counts_by_ext: counts per file extension
    - loc_by_ext: naive line counts per extension (text files only)
    - total_files: total number of files
    """
    file_counts_by_ext: Dict[str, int] = {}
    loc_by_ext: Dict[str, int] = {}
    total_files = 0

    for dirpath, dirnames, filenames in os.walk(root):
        # Skip hidden directories like .git, .venv by default
        dirnames[:] = [d for d in dirnames if not d.startswith(".")]
        for filename in filenames:
            total_files += 1
            ext = Path(filename).suffix.lower() or "<no_ext>"
            file_counts_by_ext[ext] = file_counts_by_ext.get(ext, 0) + 1

            # Only attempt simple LOC counting for likely text/code files
            if ext in {".py", ".js", ".ts", ".go", ".rs", ".md", ".yml", ".yaml", ".json", ".txt"}:
                file_path = Path(dirpath) / filename
                try:
                    with file_path.open("r", encoding="utf-8", errors="ignore") as f:
                        loc = sum(1 for _ in f)
                    loc_by_ext[ext] = loc_by_ext.get(ext, 0) + loc
                except Exception:
                    # Non-fatal; skip problematic files
                    continue

    return file_counts_by_ext, loc_by_ext, total_files


def check_key_docs(root: Path) -> Dict[str, List[str]]:
    """Check for presence of key documentation files anywhere below root."""
    found: Dict[str, List[str]] = {name: [] for name in KEY_DOCS}
    for doc_name in KEY_DOCS:
        for path in root.rglob(doc_name):
            found[doc_name].append(str(path.relative_to(root)))
    return found


def qualitative_complexity(total_files: int, total_loc: int) -> str:
    """Return a simple qualitative complexity label based on size metrics."""
    if total_loc == 0 and total_files == 0:
        return "Empty or metadata-only project."
    score = math.log10(max(total_loc, 1)) + math.log10(max(total_files, 1))
    if score < 3:
        return "Very small / simple project."
    if score < 4:
        return "Small to medium project."
    if score < 5:
        return "Medium project with moderate complexity."
    if score < 6:
        return "Large project; non-trivial complexity."
    return "Very large or monorepo-scale project."


def generate_report(
    root: Path,
    file_counts: Dict[str, int],
    loc_by_ext: Dict[str, int],
    total_files: int,
) -> str:
    total_loc = sum(loc_by_ext.values())
    complexity = qualitative_complexity(total_files, total_loc)

    lines: List[str] = []
    lines.append(f"# Project Intake Report â€” {root.name}")
    lines.append("")
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
    lines.append("## 1. Overview\n")
    lines.append(f"- Root: `{root}`")
    lines.append(f"- Total files: {total_files}")
    lines.append(f"- Total approximate lines of text/code (selected extensions): {total_loc}")
    lines.append(f"- Qualitative complexity: {complexity}\n")

    lines.append("## 2. File Types & Counts\n")
    if not file_counts:
        lines.append("No files found.\n")
    else:
        lines.append("| Extension | File Count | Approx LOC |\n|-----------|------------|-----------|\n")
        for ext, count in sorted(file_counts.items(), key=lambda kv: kv[0]):
            loc = loc_by_ext.get(ext, 0)
            lines.append(f"| `{ext}` | {count} | {loc} |")

        lines.append("")  # extra newline

    lines.append("## 3. Key Documentation Files\n")
    found_docs = check_key_docs(root)
    for doc_name, paths in found_docs.items():
        if paths:
            lines.append(f"- **{doc_name}**: present at:")
            for p in paths:
                lines.append(f"  - `{p}`")
        else:
            lines.append(f"- **{doc_name}**: **NOT FOUND** (consider adding from template bundle.)")
    lines.append("")  # newline

    lines.append("## 4. Rough Time & Memory Hints\n")
    lines.append("> These are **very rough heuristic hints**, not guarantees.\n")
    if total_loc == 0:
        lines.append(
            "- Project appears to have no counted text/code files. AI tasks will likely be input-limited by external context rather than code size.\n"
        )
    else:
        if total_loc < 1_000:
            lines.append("- Codebase is small; full-context analysis by a single LLM call is feasible.")
        elif total_loc < 20_000:
            lines.append("- Codebase is moderate; chunking strategies and careful prompt design recommended.")
        else:
            lines.append(
                "- Codebase is large; multi-pass or multi-agent strategies and indexing (RAG) are recommended."
            )

        lines.append(
            "- For expensive operations (e.g., full-repo refactors), plan work in batches and track via TASKS.md and Linear."
        )

    lines.append("")  # newline

    lines.append("## 5. Suggested Next Actions\n")
    lines.append("- Ensure `docs/` contains the standardized templates (SRS, FEATURES, PROJECT_SUMMARY, TASKS, JOURNAL).")
    lines.append("- Run `env_snapshot.py` (if not already done) and link the resulting JSON in PROJECT_SUMMARY.md.")
    lines.append("- Open a Linear epic using the templates in LINEAR_TEMPLATES.md.")
    lines.append("- Start a JOURNAL entry describing this initial intake and any immediate follow-up tasks.\n")

    return "\n".join(lines)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Analyze a project directory and emit a Markdown intake report."
    )
    parser.add_argument(
        "-r",
        "--root",
        default=".",
        help="Root directory of the project (default: current directory)",
    )
    parser.add_argument(
        "-o",
        "--output",
        default="project_intake_report.md",
        help="Output Markdown file path (default: project_intake_report.md)",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    root = Path(args.root).expanduser().resolve()
    output_path = Path(args.output).expanduser().resolve()

    if not root.exists() or not root.is_dir():
        print(
            f"[project_intake_audit] ERROR: root directory does not exist or is not a directory: {root}",
            file=sys.stderr,
        )
        sys.exit(1)

    file_counts, loc_by_ext, total_files = scan_tree(root)
    report = generate_report(root, file_counts, loc_by_ext, total_files)

    try:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with output_path.open("w", encoding="utf-8") as f:
            f.write(report)
        print(f"[project_intake_audit] Wrote intake report to: {output_path}")
    except Exception as exc:
        print(
            f"[project_intake_audit] ERROR: failed to write report to {output_path}: {exc}",
            file=sys.stderr,
        )
        sys.exit(1)


if __name__ == "__main__":
    main()
